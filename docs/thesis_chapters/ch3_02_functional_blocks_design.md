# Глава 3. Разработка приложения (с фокусом на архитектуру)

## 3.2 Проектирование основных функциональных блоков

В данном разделе подробно рассматривается проектирование ключевых функциональных блоков системы, обеспечивающих взаимодействие пользователя с разработанной ML-моделью. Описание строится на основе архитектурных решений, изложенных в разделе 3.1 и технической документации (`docs/technical/architecture/application_architecture.md`). Основное внимание уделяется потокам данных, интерфейсам взаимодействия компонентов и логике, реализованной для демонстрации процесса классификации клиентов.

### 3.2.1 Проектирование обработки данных в API для классификации

API-сервис, реализованный на FastAPI, является центральным узлом для обработки входящих данных от пользователя, предназначенных для классификации. Проектирование этого блока нацелено на обеспечение гибкости ввода данных и их корректной подготовки перед передачей в модуль машинного обучения.

**Механизмы приема данных:**

Система поддерживает два основных способа предоставления данных для классификации через пользовательский интерфейс, которые обрабатываются соответствующими эндпоинтами API:

1.  **Загрузка CSV-файла:** Пользователь может загрузить файл в формате CSV, содержащий данные по одному или нескольким клиентам. В FastAPI для этого используется тип `UploadFile` из `fastapi`. API-эндпоинт (например, `/classify/csv`) принимает этот файл, считывает его содержимое (например, с помощью `pandas.read_csv()`) и преобразует в структуру, удобную для дальнейшей обработки (DataFrame).
    *   **Валидация:** На этом этапе выполняется базовая валидация формата файла и наличия ожидаемых столбцов, имена которых известны из процесса обучения модели.

2.  **Ручной ввод данных:** Пользователь может ввести данные для одного клиента через веб-форму. Эти данные поступают на соответствующий API-эндпоинт (например, `/classify/manual`) в виде структурированного запроса. Для валидации таких данных на стороне FastAPI активно используются Pydantic-модели, которые описывают ожидаемые поля, их типы и возможные ограничения. Это позволяет автоматически проверять корректность введенных данных и возвращать информативные ошибки в случае их несоответствия.

**Подготовка данных в API:**

После приема и первичной валидации, данные, независимо от способа их поступления, приводятся к единому формату (обычно `pandas DataFrame`), который затем передается в модуль, отвечающий за непосредственное взаимодействие с ML-моделью. На данном этапе в API-сервисе могут выполняться следующие подготовительные шаги:

*   **Проверка наличия ключевых признаков:** Убедиться, что все признаки, необходимые для работы модели, присутствуют.
*   **Преобразование типов:** Приведение данных к типам, ожидаемым на следующих этапах обработки (например, числовые типы для числовых признаков).
*   **Обработка очевидных пропусков:** Если какие-то обязательные поля не заполнены, может быть применена простейшая логика заполнения (например, возврат ошибки пользователю с указанием на необходимость заполнения).

Важно отметить, что основная, более сложная логика предобработки данных, такая как масштабирование числовых признаков, кодирование категориальных признаков, применение PCA или кластеризации (KMeans), инкапсулирована внутри модуля, работающего непосредственно с ML-моделью, или реализуется путем загрузки и применения ранее сохраненных трансформеров (`StandardScaler`, `MinMaxScaler`, `LabelEncoder`, `OneHotEncoder`, `PCA`, `KMeans`). Это позволяет API-сервису оставаться относительно легковесным в части логики предобработки и делегировать специфичные для ML задачи соответствующему компоненту. Такой подход также обеспечивает консистентность обработки новых данных с той, что применялась при обучении модели.

### 3.2.2 Проектирование взаимодействия с ML-моделью

После того как API-сервис подготовил входящие данные, они передаются в модуль, отвечающий за непосредственное применение модели машинного обучения. Проектирование этого взаимодействия сфокусировано на корректной загрузке артефактов моделирования, последовательном применении всех необходимых трансформаций и получении итоговых предсказаний.

**Загрузка модели и трансформеров:**

При старте API-сервиса или при первом обращении к функционалу классификации происходит загрузка обученной ML-модели и всех связанных с ней артефактов предобработки. В рамках данного проекта это включает:

*   **Основная модель классификации:** Загружается из файла `output/models/best_model.pkl` (например, модель LightGBM). Этот файл содержит сам классификатор, а также может включать метаданные, такие как список имен признаков, на которых модель обучалась (`feature_names`), и маппинг классов (`class_mapping`).
*   **Трансформеры:** Загружаются из директории `output/models/transformers/`. Сюда входят:
    *   `MinMaxScaler` и `StandardScaler` для числовых признаков.
    *   `LabelEncoder` для признака 'Пол'.
    *   Списки топ-10 локаций и one-hot энкодер для 'Точка продаж'.
    *   One-hot энкодер для категорий товаров.
    *   Модели `KMeans` и `PCA` вместе с соответствующими `StandardScaler` для подготовки данных перед их применением.
    *   Списки признаков, использованных для обучения `KMeans` (`kmeans_feature_cols.pkl`) и `PCA` (`pca_feature_cols.pkl`). Эти списки критически важны для корректного выбора и порядка столбцов из входных данных пользователя перед применением сохраненных PCA и KMeans трансформеров.

Эта логика загрузки реализована в `src/api/routes/ui_routes.py` и гарантирует, что для предсказаний используются те же объекты и параметры, что и при финальном обучении модели.

**Последовательность применения трансформаций и предсказания:**

Для новых данных, полученных от пользователя, выполняется строгая последовательность шагов, воспроизводящая пайплайн, применявшийся при обучении модели:

1.  **Базовая подготовка признаков:** Создание недостающих столбцов (если пользователь не предоставил все, например, one-hot encoded признаки) и заполнение их значениями по умолчанию (например, 0 для one-hot, средние/медианы для некоторых числовых, если такая стратегия выбрана).
2.  **Применение простых трансформеров:** Кодирование 'Пол' с помощью загруженного `LabelEncoder`, применение one-hot кодирования для категориальных признаков на основе загруженных энкодеров и списков категорий.
3.  **Подготовка данных для KMeans и PCA:** На основе сохраненных списков `kmeans_feature_cols.pkl` и `pca_feature_cols.pkl` из входного DataFrame выбираются и упорядочиваются необходимые признаки. К этим данным применяются соответствующие `StandardScaler`.
4.  **Применение KMeans и PCA:** Трансформеры `KMeans` и `PCA` применяются к подготовленным данным для получения новых признаков (номер кластера и значения PCA-компонент).
5.  **Формирование финального набора признаков:** Все полученные и исходные (обработанные) признаки собираются в единый DataFrame. Важно, чтобы порядок и набор столбцов точно соответствовали тому, что ожидает основная модель классификации (согласно `feature_names` из загруженной модели).
6.  **Обработка отсутствующих значений/признаков:** Как указано в `workflow_state.md` (TASK-010-8) и реализовано в `src/api/routes/ui_routes.py`, для признаков, которые не могут быть вычислены из пользовательского ввода (например, сложные агрегаты или PCA/KMeans компоненты, если пользователь не предоставил достаточно данных для их расчета), используется стратегия заполнения placeholder-значениями (например, средними значениями, полученными на обучающей выборке, или нулями). Это компромиссное решение для обеспечения работоспособности демонстрационного UI.
7.  **Получение предсказаний:** Подготовленный DataFrame передается в метод `.predict()` загруженной ML-модели. Модель возвращает числовые метки классов.
8.  **Интерпретация предсказаний:** Числовые метки классов преобразуются в человекочитаемые названия сегментов лояльности (например, 'Высоколояльные', 'Отток') с использованием `class_mapping`, загруженного вместе с моделью.

Этот процесс гарантирует, что данные, подаваемые на вход модели для предсказания, проходят ту же самую или максимально приближенную обработку, что и данные, на которых модель обучалась, что является ключевым фактором для получения корректных результатов классификации.

### 3.2.3 Проектирование пользовательского интерфейса для демонстрации

Пользовательский интерфейс (UI) разработан с целью наглядной демонстрации работы системы классификации клиентов и предоставления пользователю (например, аналитику или лицу, принимающему решения) интерактивного способа взаимодействия с ML-моделью. Учитывая фокус ВКР на разработке самой модели и архитектуры, UI реализован как минимально необходимый, но функциональный веб-интерфейс.

**Технологии и структура:**

*   **Серверная часть UI:** Обслуживается тем же FastAPI-приложением, которое предоставляет API. Для генерации HTML-страниц используется шаблонизатор Jinja2.
*   **Клиентская часть UI:** Базовый HTML, CSS для стилизации (файл `src/static/css/styles.css`) и минимальное количество JavaScript для улучшения интерактивности (например, для отрисовки диаграмм с использованием библиотеки Chart.js, если это было реализовано, или для динамического обновления частей страницы без перезагрузки, если это требуется).
*   **Шаблоны:** HTML-код организован с использованием системы шаблонов Jinja2, что позволяет переиспользовать общие элементы страниц (например, шапку, подвал, навигацию). Основные шаблоны находятся в директории `src/templates/`:
    *   `base.html`: Базовый шаблон, определяющий общую структуру всех страниц.
    *   `index.html`: Главная страница приложения, на которой сосредоточены основные элементы взаимодействия.
    *   `partials/`: Директория с частичными шаблонами, которые могут вставляться в основные страницы. Например:
        *   `model_info.html`: Отображает информацию о загруженной ML-модели.
        *   `loyalty_distribution.html`: Отображает диаграмму распределения клиентов по сегментам лояльности.
        *   `classification_results_table.html`: Форматирует и отображает результаты пакетной классификации в виде таблицы.
        *   `classification_result_display.html`: Отображает результат классификации для одного клиента (при ручном вводе) и информационные сообщения.

**Основные функциональные элементы UI:**

1.  **Отображение информации о модели (на главной странице, через `model_info.html`):**
    *   Выводится название активной ML-модели, ее версия (если доступно) и, возможно, ключевые метрики качества, полученные при ее обучении.
    *   Эта информация помогает пользователю понять, какая именно модель используется для предсказаний.

2.  **Формы для ввода/загрузки данных (на главной странице `index.html`):**
    *   **Форма для ручного ввода:** Позволяет пользователю ввести значения признаков для одного клиента. Для удобства пользователя могут быть приведены подсказки о формате и ожидаемых значениях.
    *   **Форма для загрузки CSV-файла:** Позволяет загрузить файл с данными нескольких клиентов для пакетной классификации. Приводится информация об ожидаемой структуре CSV-файла (названия столбцов, разделитель).
    *   Пользователю также предоставляется информация о том, как будут обрабатываться признаки, особенно те, которые сложно или невозможно ввести вручную (например, PCA-компоненты, результат кластеризации). Указывается, что для таких признаков будут использованы placeholder-значения или они будут рассчитаны, если это возможно на основе введенных данных.

3.  **Отображение результатов классификации (через `classification_result_display.html` и `classification_results_table.html`):
    *   **Для ручного ввода:** После отправки формы результат (предсказанный сегмент лояльности и, возможно, оценка уверенности) отображается непосредственно на странице.
    *   **Для CSV-файла:** Результаты классификации для всех клиентов из файла отображаются в виде таблицы. Таблица включает идентификатор клиента и предсказанный сегмент лояльности.
    *   Могут выводиться информационные сообщения о статусе обработки, ошибках валидации данных или успешном завершении классификации.

4.  **Визуализация распределения по сегментам (на главной странице, через `loyalty_distribution.html`):
    *   Отображается диаграмма (например, круговая или столбчатая), показывающая процентное и количественное распределение клиентов по предсказанным сегментам лояльности. Эта визуализация обновляется после каждой успешной операции классификации (особенно пакетной) или может показывать общее распределение на основе последних доступных данных.
    *   Для отрисовки может использоваться JavaScript-библиотека (например, Chart.js), данные для которой передаются из FastAPI в шаблон.

Проектирование UI было направлено на простоту использования и наглядность представления информации, необходимой для демонстрации ключевых возможностей разработанной системы классификации клиентов. 