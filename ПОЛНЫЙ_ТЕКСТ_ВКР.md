# Глава 2. Разработка моделей машинного обучения

## Введение

В данной главе подробно описывается процесс разработки моделей машинного обучения, предназначенных для классификации клиентов компании Acoola по уровню их лояльности. Основная цель этой главы – продемонстрировать все этапы создания эффективного инструмента для анализа клиентского поведения, начиная от подготовки данных и заканчивая выбором и оптимизацией наиболее подходящей модели.

Глава охватывает следующие ключевые аспекты:
*   **Описание используемых данных:** Характеристика исходного набора данных, предоставленного компанией, включая описание его структуры и ключевых атрибутов, релевантных для задачи оценки лояльности.
*   **Сбор и предобработка данных:** Детальное описание процедур, примененных для очистки, трансформации и подготовки данных к этапу моделирования. Этот раздел включает методы обработки пропущенных значений, выбросов, кодирования категориальных признаков и генерации новых признаков, включая разработку комплексного показателя лояльности.
*   **Разработка моделей машинного обучения:** Описание процесса выбора, обучения и первоначальной оценки различных алгоритмов классификации, таких как логистическая регрессия, случайный лес, градиентный бустинг (XGBoost, LightGBM) и другие. Рассматривается также создание ансамблевых моделей.
*   **Тестирование и оптимизация моделей:** Представление методик оценки качества моделей, включая кросс-валидацию и анализ метрик (точность, полнота, F1-мера). Описывается процесс настройки гиперпараметров для достижения наилучшей производительности и методы интерпретации моделей для понимания вклада различных признаков.

Результатом работы, описанной в этой главе, является набор обученных и оптимизированных моделей, способных с высокой точностью классифицировать клиентов по степени их приверженности бренду, что является основой для дальнейшей разработки системы поддержки принятия решений в области управления взаимоотношениями с клиентами. 

<br><hr><br>

# Глава 3. Разработка приложения (с фокусом на архитектуру)

## Введение

Третья глава выпускной квалификационной работы посвящена вопросам проектирования и частичной реализации программного решения, предназначенного для демонстрации возможностей разработанной в предыдущей главе модели машинного обучения по классификации клиентов. Учитывая ограниченные временные рамки и основной фокус исследования на аспектах машинного обучения, создание полнофункционального промышленного приложения не входило в задачи данной работы. Вместо этого, усилия были сконцентрированы на разработке четкой архитектуры системы, проектировании ключевых компонентов и создании минимально необходимого функционала для наглядной демонстрации результатов классификации.

Основная цель данной главы – описать архитектурные решения, принятые для обеспечения взаимодействия пользователя с обученной ML-моделью, а также представить дизайн и реализацию интерфейса для демонстрации. Акцент сделан на структуре системы, выборе технологий и принципах взаимодействия ее компонентов.

Глава включает следующие основные разделы:

*   **Проектирование архитектуры приложения:** Описывается общая архитектура предлагаемой системы, ее основные компоненты (например, API-сервер, модуль взаимодействия с ML-моделью, пользовательский интерфейс), их назначение и взаимосвязи. Рассматривается структура кода и выбор технологического стека (Python, FastAPI).
*   **Проектирование и реализация основных функциональных блоков:** Детализируется проектирование серверной части (API на FastAPI) для загрузки модели, приема данных от пользователя и возврата результатов классификации. Также описывается разработка минимального пользовательского веб-интерфейса, позволяющего загружать данные и просматривать результаты работы модели.
*   **Стратегия тестирования и оценки эффективности:** Излагаются подходы к тестированию разработанных компонентов, включая план функционального тестирования и критерии оценки работоспособности демонстрационного приложения.

Таким образом, данная глава представляет концептуальное и частично реализованное решение, которое позволяет использовать разработанную ML-модель на практике для получения предсказаний лояльности клиентов и демонстрирует потенциал ее интеграции в более крупные бизнес-системы. 

<br><hr><br>

# Глава 3. Разработка приложения (с фокусом на архитектуру)

## 3.1 Проектирование архитектуры приложения

Для обеспечения эффективного взаимодействия с разработанной моделью машинного обучения и демонстрации ее возможностей была спроектирована архитектура программного решения. Основной целью архитектурного проектирования являлось создание гибкой, масштабируемой и поддерживаемой системы, даже при условии реализации только минимально необходимого функционала для демонстрации в рамках данной работы.

### 3.1.1 Общее описание архитектурного решения

Предлагаемая система классификации клиентов Acoola спроектирована с использованием API-first подхода и ориентирована на четкое разделение ответственности между компонентами. В основе лежит многокомпонентная архитектура, где каждый основной блок выполняет свою специфическую роль.

**Ключевые компоненты системы:**

1.  **API Сервис (Backend):**
    *   **Назначение:** Является ядром системы, обрабатывает все входящие запросы, управляет бизнес-логикой, взаимодействует с базой данных, хранилищем файлов и модулем машинного обучения. Предоставляет RESTful API для взаимодействия с внешними системами и пользовательским интерфейсом.
    *   **Технологии:** Реализован на Python с использованием фреймворка FastAPI, который обеспечивает высокую производительность, автоматическую валидацию данных на основе Pydantic-схем и генерацию интерактивной API-документации (Swagger UI / ReDoc).

2.  **Модуль Машинного Обучения (ML Service/Module):**
    *   **Назначение:** Инкапсулирует логику работы с ML-моделями. Отвечает за загрузку обученной модели (например, из `.pkl` файла), предобработку входных данных в формат, ожидаемый моделью, выполнение предсказаний (классификации) и возврат результатов. В рамках текущей реализации, ML-логика может быть тесно интегрирована с API Сервисом или выделена в отдельный логический модуль.
    *   **Технологии:** Python, библиотеки `scikit-learn`, `pandas`, `numpy`, `joblib`/`pickle` для загрузки моделей.

3.  **Пользовательский Интерфейс (Frontend):**
    *   **Назначение:** Предоставляет пользователю (например, аналитику) возможность взаимодействия с системой для демонстрации ее работы. Включает формы для ручного ввода данных или загрузки CSV-файла с клиентскими данными, отображение информации об активной модели, визуализацию распределения клиентов по сегментам лояльности и представление результатов классификации.
    *   **Технологии:** Для минимизации сложности и обеспечения быстрой разработки, интерфейс реализован с использованием HTML-шаблонов (Jinja2), обслуживаемых FastAPI, с базовым стилистическим оформлением (CSS) и, при необходимости, минимальным использованием JavaScript для интерактивности.

4.  **База Данных (например, PostgreSQL):**
    *   **Назначение:** Хранение структурированных данных, таких как информация о пользователях (если предполагается аутентификация), метаданные ML-моделей, возможно, история классификаций или агрегированные данные клиентов, если это необходимо для расширенного функционала. В минимальной конфигурации для демонстрации ее использование может быть ограничено.
    *   **Технологии:** Реляционная СУБД, например, PostgreSQL. Взаимодействие из Python может осуществляться через ORM (например, SQLAlchemy).

5.  **Хранилище Файлов (например, локальная ФС или MinIO):**
    *   **Назначение:** Хранение сериализованных ML-моделей, артефактов предобработки (скейлеры, энкодеры), а также загружаемых пользователем файлов с данными и, возможно, генерируемых отчетов.
    *   **Технологии:** Локальная файловая система для простоты развертывания или S3-совместимое хранилище (например, MinIO) для большей гибкости.

**Взаимодействие компонентов:**
Пользователь взаимодействует с системой через Пользовательский Интерфейс, который отправляет запросы к API Сервису. API Сервис, в свою очередь, обрабатывает запрос, при необходимости обращается к Модулю Машинного Обучения для получения предсказания, может взаимодействовать с Базой Данных и Хранилищем Файлов, после чего возвращает ответ Пользовательскому Интерфейсу. Интерактивная документация API (Swagger UI), предоставляемая FastAPI, также служит важным инструментом для разработчиков и аналитиков.

### 3.1.2 Структура кода и основные модули

Проект имеет модульную структуру, направленную на логическое разделение функциональности и упрощение поддержки. Основная структура директорий и файлов выглядит следующим образом:

*   **`src/`**: Корневая директория с исходным кодом приложения.
    *   `main.py`: Точка входа в приложение FastAPI, инициализация основных компонентов, подключение роутеров.
    *   **`api/`**: Модули, связанные с реализацией API.
        *   `routes/`: Определения эндпоинтов API (маршрутов). Например, `ui_routes.py` для обслуживания запросов от пользовательского интерфейса и выполнения классификации.
        *   `schemas/` (если используется): Pydantic-схемы для валидации данных запросов и ответов.
    *   **`modeling/`**: Модули, связанные с разработкой и использованием ML-моделей.
        *   `models/`: Содержит реализации классов для различных алгоритмов машинного обучения.
        *   `optimization/`: Модули для оптимизации гиперпараметров моделей (например, с использованием Optuna).
        *   `evaluation/`: Функции и классы для оценки качества моделей.
        *   `interpretation/`: Инструменты для интерпретации моделей (например, SHAP).
        *   `model_training.py`: Скрипт или модуль для оркестрации процесса обучения и оценки моделей.
    *   **`preprocessing/`**: Модули для предобработки данных и конструирования признаков.
        *   `cleaners/`, `encoders/`, `feature_engineering/`: Модули, реализующие специфические шаги предобработки.
        *   `data_preprocessing.py`: Основной модуль, агрегирующий шаги предобработки.
        *   `enhanced_loyalty_features.py`: Модуль для расчета расширенных признаков лояльности.
    *   **`utils/`**: Вспомогательные утилиты (например, для работы с конфигурацией, логированием, общие хелперы).
    *   **`static/`**: Статические файлы для frontend (CSS, JavaScript, изображения).
    *   **`templates/`**: HTML-шаблоны (Jinja2) для пользовательского интерфейса.
*   **`dataset/`**: Директория для хранения исходных наборов данных.
*   **`output/`**: Директория для сохранения результатов работы пайплайнов:
    *   `models/`: Сохраненные обученные модели, трансформеры.
    *   `results/`: Таблицы с метриками, текстовые отчеты, логи.
    *   `feature_importance/`: Данные и визуализации по важности признаков.
    *   `visualizations/`: Общие визуализации, генерируемые в ходе анализа данных.
*   **`docs/`**: Документация проекта.
    *   `business/`: Бизнес-описание.
    *   `technical/`: Техническая документация, включая описание архитектуры (`architecture/application_architecture.md`), обзор визуализаций.
    *   `thesis_chapters/`: Markdown-файлы с текстом глав ВКР.
*   **`tests/`**: Модульные, интеграционные и e2e тесты (структура может варьироваться).
*   `requirements.txt`: Список зависимостей проекта.
*   `run_pipeline.py`: Основной скрипт для запуска полного конвейера обработки данных и обучения моделей.

Такая структура обеспечивает хорошее разделение ответственности (Separation of Concerns) и способствует более легкой навигации по кодовой базе, ее тестированию и дальнейшему развитию. 

<br><hr><br>

# Глава 3. Разработка приложения (с фокусом на архитектуру)

## 3.2 Проектирование основных функциональных блоков

В данном разделе подробно рассматривается проектирование ключевых функциональных блоков системы, обеспечивающих взаимодействие пользователя с разработанной ML-моделью. Описание строится на основе архитектурных решений, изложенных в разделе 3.1 и технической документации (`docs/technical/architecture/application_architecture.md`). Основное внимание уделяется потокам данных, интерфейсам взаимодействия компонентов и логике, реализованной для демонстрации процесса классификации клиентов.

### 3.2.1 Проектирование обработки данных в API для классификации

API-сервис, реализованный на FastAPI, является центральным узлом для обработки входящих данных от пользователя, предназначенных для классификации. Проектирование этого блока нацелено на обеспечение гибкости ввода данных и их корректной подготовки перед передачей в модуль машинного обучения.

**Механизмы приема данных:**

Система поддерживает два основных способа предоставления данных для классификации через пользовательский интерфейс, которые обрабатываются соответствующими эндпоинтами API:

1.  **Загрузка CSV-файла:** Пользователь может загрузить файл в формате CSV, содержащий данные по одному или нескольким клиентам. В FastAPI для этого используется тип `UploadFile` из `fastapi`. API-эндпоинт (например, `/classify/csv`) принимает этот файл, считывает его содержимое (например, с помощью `pandas.read_csv()`) и преобразует в структуру, удобную для дальнейшей обработки (DataFrame).
    *   **Валидация:** На этом этапе выполняется базовая валидация формата файла и наличия ожидаемых столбцов, имена которых известны из процесса обучения модели.

2.  **Ручной ввод данных:** Пользователь может ввести данные для одного клиента через веб-форму. Эти данные поступают на соответствующий API-эндпоинт (например, `/classify/manual`) в виде структурированного запроса. Для валидации таких данных на стороне FastAPI активно используются Pydantic-модели, которые описывают ожидаемые поля, их типы и возможные ограничения. Это позволяет автоматически проверять корректность введенных данных и возвращать информативные ошибки в случае их несоответствия.

**Подготовка данных в API:**

После приема и первичной валидации, данные, независимо от способа их поступления, приводятся к единому формату (обычно `pandas DataFrame`), который затем передается в модуль, отвечающий за непосредственное взаимодействие с ML-моделью. На данном этапе в API-сервисе могут выполняться следующие подготовительные шаги:

*   **Проверка наличия ключевых признаков:** Убедиться, что все признаки, необходимые для работы модели, присутствуют.
*   **Преобразование типов:** Приведение данных к типам, ожидаемым на следующих этапах обработки (например, числовые типы для числовых признаков).
*   **Обработка очевидных пропусков:** Если какие-то обязательные поля не заполнены, может быть применена простейшая логика заполнения (например, возврат ошибки пользователю с указанием на необходимость заполнения).

Важно отметить, что основная, более сложная логика предобработки данных, такая как масштабирование числовых признаков, кодирование категориальных признаков, применение PCA или кластеризации (KMeans), инкапсулирована внутри модуля, работающего непосредственно с ML-моделью, или реализуется путем загрузки и применения ранее сохраненных трансформеров (`StandardScaler`, `MinMaxScaler`, `LabelEncoder`, `OneHotEncoder`, `PCA`, `KMeans`). Это позволяет API-сервису оставаться относительно легковесным в части логики предобработки и делегировать специфичные для ML задачи соответствующему компоненту. Такой подход также обеспечивает консистентность обработки новых данных с той, что применялась при обучении модели.

### 3.2.2 Проектирование взаимодействия с ML-моделью

После того как API-сервис подготовил входящие данные, они передаются в модуль, отвечающий за непосредственное применение модели машинного обучения. Проектирование этого взаимодействия сфокусировано на корректной загрузке артефактов моделирования, последовательном применении всех необходимых трансформаций и получении итоговых предсказаний.

**Загрузка модели и трансформеров:**

При старте API-сервиса или при первом обращении к функционалу классификации происходит загрузка обученной ML-модели и всех связанных с ней артефактов предобработки. В рамках данного проекта это включает:

*   **Основная модель классификации:** Загружается из файла `output/models/best_model.pkl` (например, модель LightGBM). Этот файл содержит сам классификатор, а также может включать метаданные, такие как список имен признаков, на которых модель обучалась (`feature_names`), и маппинг классов (`class_mapping`).
*   **Трансформеры:** Загружаются из директории `output/models/transformers/`. Сюда входят:
    *   `MinMaxScaler` и `StandardScaler` для числовых признаков.
    *   `LabelEncoder` для признака 'Пол'.
    *   Списки топ-10 локаций и one-hot энкодер для 'Точка продаж'.
    *   One-hot энкодер для категорий товаров.
    *   Модели `KMeans` и `PCA` вместе с соответствующими `StandardScaler` для подготовки данных перед их применением.
    *   Списки признаков, использованных для обучения `KMeans` (`kmeans_feature_cols.pkl`) и `PCA` (`pca_feature_cols.pkl`). Эти списки критически важны для корректного выбора и порядка столбцов из входных данных пользователя перед применением сохраненных PCA и KMeans трансформеров.

Эта логика загрузки реализована в `src/api/routes/ui_routes.py` и гарантирует, что для предсказаний используются те же объекты и параметры, что и при финальном обучении модели.

**Последовательность применения трансформаций и предсказания:**

Для новых данных, полученных от пользователя, выполняется строгая последовательность шагов, воспроизводящая пайплайн, применявшийся при обучении модели:

1.  **Базовая подготовка признаков:** Создание недостающих столбцов (если пользователь не предоставил все, например, one-hot encoded признаки) и заполнение их значениями по умолчанию (например, 0 для one-hot, средние/медианы для некоторых числовых, если такая стратегия выбрана).
2.  **Применение простых трансформеров:** Кодирование 'Пол' с помощью загруженного `LabelEncoder`, применение one-hot кодирования для категориальных признаков на основе загруженных энкодеров и списков категорий.
3.  **Подготовка данных для KMeans и PCA:** На основе сохраненных списков `kmeans_feature_cols.pkl` и `pca_feature_cols.pkl` из входного DataFrame выбираются и упорядочиваются необходимые признаки. К этим данным применяются соответствующие `StandardScaler`.
4.  **Применение KMeans и PCA:** Трансформеры `KMeans` и `PCA` применяются к подготовленным данным для получения новых признаков (номер кластера и значения PCA-компонент).
5.  **Формирование финального набора признаков:** Все полученные и исходные (обработанные) признаки собираются в единый DataFrame. Важно, чтобы порядок и набор столбцов точно соответствовали тому, что ожидает основная модель классификации (согласно `feature_names` из загруженной модели).
6.  **Обработка отсутствующих значений/признаков:** Как указано в `workflow_state.md` (TASK-010-8) и реализовано в `src/api/routes/ui_routes.py`, для признаков, которые не могут быть вычислены из пользовательского ввода (например, сложные агрегаты или PCA/KMeans компоненты, если пользователь не предоставил достаточно данных для их расчета), используется стратегия заполнения placeholder-значениями (например, средними значениями, полученными на обучающей выборке, или нулями). Это компромиссное решение для обеспечения работоспособности демонстрационного UI.
7.  **Получение предсказаний:** Подготовленный DataFrame передается в метод `.predict()` загруженной ML-модели. Модель возвращает числовые метки классов.
8.  **Интерпретация предсказаний:** Числовые метки классов преобразуются в человекочитаемые названия сегментов лояльности (например, 'Высоколояльные', 'Отток') с использованием `class_mapping`, загруженного вместе с моделью.

Этот процесс гарантирует, что данные, подаваемые на вход модели для предсказания, проходят ту же самую или максимально приближенную обработку, что и данные, на которых модель обучалась, что является ключевым фактором для получения корректных результатов классификации.

### 3.2.3 Проектирование пользовательского интерфейса для демонстрации

Пользовательский интерфейс (UI) разработан с целью наглядной демонстрации работы системы классификации клиентов и предоставления пользователю (например, аналитику или лицу, принимающему решения) интерактивного способа взаимодействия с ML-моделью. Учитывая фокус ВКР на разработке самой модели и архитектуры, UI реализован как минимально необходимый, но функциональный веб-интерфейс.

**Технологии и структура:**

*   **Серверная часть UI:** Обслуживается тем же FastAPI-приложением, которое предоставляет API. Для генерации HTML-страниц используется шаблонизатор Jinja2.
*   **Клиентская часть UI:** Базовый HTML, CSS для стилизации (файл `src/static/css/styles.css`) и минимальное количество JavaScript для улучшения интерактивности (например, для отрисовки диаграмм с использованием библиотеки Chart.js, если это было реализовано, или для динамического обновления частей страницы без перезагрузки, если это требуется).
*   **Шаблоны:** HTML-код организован с использованием системы шаблонов Jinja2, что позволяет переиспользовать общие элементы страниц (например, шапку, подвал, навигацию). Основные шаблоны находятся в директории `src/templates/`:
    *   `base.html`: Базовый шаблон, определяющий общую структуру всех страниц.
    *   `index.html`: Главная страница приложения, на которой сосредоточены основные элементы взаимодействия.
    *   `partials/`: Директория с частичными шаблонами, которые могут вставляться в основные страницы. Например:
        *   `model_info.html`: Отображает информацию о загруженной ML-модели.
        *   `loyalty_distribution.html`: Отображает диаграмму распределения клиентов по сегментам лояльности.
        *   `classification_results_table.html`: Форматирует и отображает результаты пакетной классификации в виде таблицы.
        *   `classification_result_display.html`: Отображает результат классификации для одного клиента (при ручном вводе) и информационные сообщения.

**Основные функциональные элементы UI:**

1.  **Отображение информации о модели (на главной странице, через `model_info.html`):**
    *   Выводится название активной ML-модели, ее версия (если доступно) и, возможно, ключевые метрики качества, полученные при ее обучении.
    *   Эта информация помогает пользователю понять, какая именно модель используется для предсказаний.

2.  **Формы для ввода/загрузки данных (на главной странице `index.html`):**
    *   **Форма для ручного ввода:** Позволяет пользователю ввести значения признаков для одного клиента. Для удобства пользователя могут быть приведены подсказки о формате и ожидаемых значениях.
    *   **Форма для загрузки CSV-файла:** Позволяет загрузить файл с данными нескольких клиентов для пакетной классификации. Приводится информация об ожидаемой структуре CSV-файла (названия столбцов, разделитель).
    *   Пользователю также предоставляется информация о том, как будут обрабатываться признаки, особенно те, которые сложно или невозможно ввести вручную (например, PCA-компоненты, результат кластеризации). Указывается, что для таких признаков будут использованы placeholder-значения или они будут рассчитаны, если это возможно на основе введенных данных.

3.  **Отображение результатов классификации (через `classification_result_display.html` и `classification_results_table.html`):
    *   **Для ручного ввода:** После отправки формы результат (предсказанный сегмент лояльности и, возможно, оценка уверенности) отображается непосредственно на странице.
    *   **Для CSV-файла:** Результаты классификации для всех клиентов из файла отображаются в виде таблицы. Таблица включает идентификатор клиента и предсказанный сегмент лояльности.
    *   Могут выводиться информационные сообщения о статусе обработки, ошибках валидации данных или успешном завершении классификации.

4.  **Визуализация распределения по сегментам (на главной странице, через `loyalty_distribution.html`):
    *   Отображается диаграмма (например, круговая или столбчатая), показывающая процентное и количественное распределение клиентов по предсказанным сегментам лояльности. Эта визуализация обновляется после каждой успешной операции классификации (особенно пакетной) или может показывать общее распределение на основе последних доступных данных.
    *   Для отрисовки может использоваться JavaScript-библиотека (например, Chart.js), данные для которой передаются из FastAPI в шаблон.

Проектирование UI было направлено на простоту использования и наглядность представления информации, необходимой для демонстрации ключевых возможностей разработанной системы классификации клиентов. 

<br><hr><br>

# Глава 3. Разработка приложения (с фокусом на архитектуру)

## 3.3 Стратегия тестирования и оценки эффективности демонстрационного приложения

Поскольку основной целью разработки приложения в рамках данной ВКР являлась демонстрация возможностей ML-модели и ее интеграции в потенциальный рабочий процесс, стратегия тестирования фокусируется на проверке корректности работы ключевого функционала и обеспечении стабильной демонстрации. Полномасштабное тестирование, включающее нагрузочные тесты, тесты безопасности или длительное юзабилити-тестирование, выходит за рамки текущей работы.

### 3.3.1 План функционального тестирования

Функциональное тестирование направлено на проверку того, что каждый компонент и система в целом выполняют свои заявленные функции корректно. Тестирование будет проводиться вручную на основе следующих сценариев:

**1. Тестирование API-сервиса (FastAPI):**

*   **Загрузка ML-модели и трансформеров:**
    *   Проверка успешной загрузки основной модели (`best_model.pkl`) при старте приложения или первом обращении.
    *   Проверка успешной загрузки всех необходимых трансформеров из директории `output/models/transformers/` (скейлеры, энкодеры, PCA, KMeans, списки признаков).
    *   Проверка корректной обработки ситуации отсутствия файлов моделей или трансформеров (например, вывод информативного сообщения об ошибке, если это предусмотрено).
*   **Эндпоинт для классификации данных из CSV-файла (`/classify/csv` или аналогичный):**
    *   Тест с корректным CSV-файлом: проверка, что данные правильно считываются, обрабатываются и возвращаются предсказанные сегменты для всех клиентов.
    *   Тест с CSV-файлом, имеющим неверный формат или разделитель: проверка, что API возвращает ошибку.
    *   Тест с CSV-файлом, где отсутствуют некоторые обязательные колонки: проверка корректной обработки (например, возврат ошибки или использование значений по умолчанию, если это предусмотрено логикой).
    *   Тест с CSV-файлом, содержащим некорректные типы данных в колонках: проверка устойчивости API и корректности обработки ошибок.
    *   Тест с пустым CSV-файлом.
*   **Эндпоинт для классификации данных при ручном вводе (`/classify/manual` или аналогичный):**
    *   Тест с корректным набором входных данных: проверка, что данные принимаются, обрабатываются и возвращается предсказанный сегмент.
    *   Тест с отсутствующими обязательными полями: проверка, что FastAPI возвращает ошибку валидации Pydantic.
    *   Тест с некорректными типами данных (например, текст вместо числа): проверка ошибки валидации.
    *   Тест со значениями, выходящими за допустимые диапазоны (если такие проверки есть).
*   **Эндпоинт для получения информации о модели (`/model-info` или аналогичный):**
    *   Проверка, что эндпоинт возвращает корректную информацию (имя модели, метаданные).
*   **Эндпоинт для получения данных для диаграммы распределения (`/loyalty-distribution-data` или аналогичный):**
    *   Проверка, что эндпоинт возвращает данные в ожидаемом формате для построения диаграммы.

**2. Тестирование Пользовательского Интерфейса (UI):**

*   **Отображение главной страницы (`index.html`):**
    *   Проверка корректного отображения всех элементов: информация о модели, формы ввода/загрузки, блок для результатов, блок для диаграммы.
    *   Проверка загрузки и отображения информации об активной модели.
*   **Функционал ручного ввода данных:**
    *   Ввод корректных данных и отправка формы: проверка, что результат классификации отображается корректно.
    *   Ввод некорректных данных: проверка, что отображаются сообщения об ошибках валидации.
    *   Проверка реакции интерфейса на успешную/неуспешную классификацию.
*   **Функционал загрузки CSV-файла:**
    *   Загрузка корректного CSV: проверка, что результаты отображаются в таблице.
    *   Загрузка некорректного CSV (неверный формат, отсутствующие столбцы): проверка отображения сообщений об ошибках.
    *   Проверка отображения информации об ожидаемом формате CSV.
*   **Отображение результатов классификации:**
    *   Проверка четкости и понятности представления предсказанного сегмента.
    *   Для пакетной классификации – проверка корректности таблицы с результатами (наличие всех клиентов из файла, соответствие предсказаний).
*   **Отображение диаграммы распределения по сегментам:**
    *   Проверка, что диаграмма строится и отображает корректные данные.
    *   Проверка обновления диаграммы после новой операции классификации (если это предусмотрено).
*   **Общее удобство и понятность интерфейса:** Субъективная оценка того, насколько легко пользователю выполнить основные демонстрационные сценарии.

### 3.3.2 Критерии оценки работоспособности и эффективности для демонстрации

Поскольку приложение носит демонстрационный характер, основными критериями оценки будут:

1.  **Корректность выполнения основных сценариев:**
    *   Система должна правильно классифицировать клиентов как при ручном вводе, так и при загрузке CSV-файла, используя обученную модель LightGBM и соответствующие трансформеры.
    *   Результаты классификации, отображаемые в UI, должны соответствовать результатам, полученным напрямую от ML-модуля.
2.  **Стабильность работы:**
    *   Приложение не должно падать или выдавать необработанные ошибки при выполнении стандартных демонстрационных сценариев (корректный ввод, загрузка корректных файлов).
    *   Обработка некорректного ввода или файлов должна приводить к выводу понятных сообщений об ошибках, а не к отказу системы.
3.  **Наглядность демонстрации:**
    *   Пользовательский интерфейс должен четко отображать информацию о модели, позволять легко вводить/загружать данные и ясно представлять результаты классификации и распределение по сегментам.
4.  **Воспроизводимость процесса предобработки для новых данных:**
    *   Система должна корректно применять все необходимые шаги предобработки (загрузка и использование сохраненных трансформеров PCA, KMeans, скейлеров, энкодеров) к новым данным, чтобы обеспечить консистентность с процессом обучения модели.
    *   Стратегия обработки отсутствующих или невычисляемых из пользовательского ввода признаков (например, PCA-компонент) с помощью placeholder-значений должна быть реализована и не приводить к ошибкам во время демонстрации.
5.  **Соответствие документации:**
    *   Реализованный функционал должен соответствовать описанию, представленному в данной главе и в технической документации по архитектуре.

Успешное прохождение функциональных тестов по указанным сценариям и соответствие перечисленным критериям будет свидетельствовать о готовности демонстрационного приложения к представлению в рамках защиты ВКР. 

<br><hr><br>

# Глава 3. Разработка приложения (с фокусом на архитектуру)

## 3.4 Выводы по Главе 3

В рамках третьей главы выпускной квалификационной работы были рассмотрены вопросы проектирования и частичной реализации программного приложения, предназначенного для демонстрации работы разработанной ML-модели классификации клиентов по уровню лояльности. Основной акцент был сделан не на создании полнофункционального коммерческого продукта, а на разработке архитектуры и минимально необходимого интерфейса для эффективной демонстрации результатов исследования.

Ключевые результаты, достигнутые в ходе работы над данной главой, включают:

1.  **Спроектирована архитектура приложения:** Разработано архитектурное решение, основанное на API-first подходе и многокомпонентной структуре. Были определены основные компоненты системы: API-сервис на FastAPI, модуль машинного обучения, пользовательский интерфейс на базе Jinja2-шаблонов, а также потенциальное использование базы данных и хранилища файлов. Подробное описание архитектуры вынесено в техническую документацию (`docs/technical/architecture/application_architecture.md`), а в данной главе представлены ее основные аспекты и структура кода.

2.  **Детализировано проектирование основных функциональных блоков:**
    *   Описаны механизмы приема и первичной обработки данных в API-сервисе, включая поддержку загрузки CSV-файлов и ручного ввода данных с валидацией через Pydantic-схемы.
    *   Проработан процесс взаимодействия с ML-моделью: загрузка основной модели LightGBM и всех необходимых трансформеров (скейлеров, энкодеров, PCA, KMeans), а также последовательное применение этих артефактов к новым данным для получения предсказаний. Особое внимание уделено воспроизводимости шагов предобработки и стратегии обработки признаков, которые не могут быть полностью получены из пользовательского ввода.
    *   Спроектирован минималистичный пользовательский интерфейс, включающий отображение информации о модели, формы для ввода данных, вывод результатов классификации и визуализацию распределения клиентов по сегментам лояльности.

3.  **Разработана стратегия тестирования и оценки эффективности:** Предложен план функционального тестирования для API-сервиса и пользовательского интерфейса, охватывающий ключевые сценарии использования. Сформулированы критерии оценки работоспособности и эффективности демонстрационного приложения, ориентированные на корректность выполнения основных функций, стабильность и наглядность представления результатов.

Таким образом, в главе 3 были заложены основы для создания работающего прототипа системы, способного продемонстрировать практическое применение результатов машинного обучения, полученных в предыдущей главе. Спроектированная архитектура обеспечивает гибкость и потенциал для дальнейшего развития системы, в то время как реализованный минимальный функционал достаточен для достижения демонстрационных целей ВКР. Акцент на правильной интеграции ML-модели и корректной обработке данных на этапе предсказания является важным аспектом, подтверждающим жизнеспособность предложенного подхода. 

<br><hr><br>

# Заключение

В настоящей выпускной квалификационной работе было проведено исследование и разработка системы для классификации клиентов розничной сети детской одежды Acoola по уровню их лояльности. Основной целью работы являлось создание эффективной модели машинного обучения, способной идентифицировать различные сегменты клиентов, и проектирование архитектуры приложения для демонстрации ее работы.

В ходе выполнения работы были решены следующие ключевые задачи:

1.  **Проведен комплексный анализ и предобработка данных о клиентах и их транзакциях.** Исходный датасет `Concept202408.csv`, содержащий 418 888 записей, был тщательно очищен от пропущенных значений и выбросов. Были применены различные методы трансформации данных, включая Label Encoding, One-Hot Encoding, MinMaxScaler и StandardScaler, с сохранением соответствующих трансформеров для последующего использования.

2.  **Разработан и сконструирован расширенный набор признаков для оценки лояльности.** На основе агрегированных данных на уровне клиента был проведен RFM-анализ. Дополнительно были созданы 7 кастомных признаков, отражающих различные аспекты лояльности. Для обогащения признакового пространства применялись методы кластеризации K-Means (на 5 кластеров по 40 признакам) и снижения размерности PCA (3 компоненты). Итогом стал агрегированный признак `enhanced_loyalty_score`, на основе которого была сформирована бинарная целевая переменная для классификации: 'Высоколояльные' (87.37% выборки) и 'Отток' (12.63%). Для обучения моделей был отобран набор из 20 наиболее информативных признаков из 44 сгенерированных.

3.  **Разработаны, обучены и оценены различные модели машинного обучения.** Рассматривались такие алгоритмы, как Логистическая регрессия, Random Forest, Gradient Boosting (включая XGBoost и LightGBM) и SVM. Для оптимизации гиперпараметров ключевых моделей (Random Forest, XGBoost, LightGBM) использовалась библиотека Optuna с целевой метрикой F1-macro. В результате наилучшие показатели продемонстрировала модель LightGBM, достигнув F1-macro близкого к 1.0. Столь высокие метрики объясняются особенностями формирования целевой переменной `enhanced_loyalty_score` и результирующим дисбалансом классов, что сделало задачу классификации относительно простой для модели. Была проведена интерпретация лучшей модели с использованием SHAP values и встроенной важности признаков, выявившая ключевые драйверы лояльности, такие как `recency_ratio`, `monetary`, `pca_component_3`.

4.  **Спроектирована архитектура программного приложения для демонстрации работы ML-модели.** Был выбран API-first подход с использованием FastAPI для бэкенда и Jinja2-шаблонов для минимального пользовательского интерфейса. Архитектура предусматривает четкое разделение на компоненты: API-сервис, модуль машинного обучения, UI, а также опциональное использование базы данных и хранилища файлов. Подробное описание архитектуры представлено в технической документации проекта.

5.  **Детализировано проектирование основных функциональных блоков приложения.** Описаны процессы обработки входящих данных от пользователя (ручной ввод и загрузка CSV), взаимодействие с ML-моделью (загрузка модели LightGBM и всех необходимых трансформеров, применение пайплайна предобработки к новым данным), а также ключевые элементы пользовательского интерфейса для демонстрации классификации.

6.  **Разработана стратегия тестирования демонстрационного приложения.** Сформулированы план функционального тестирования и критерии оценки работоспособности, направленные на проверку корректности выполнения основных сценариев и стабильности приложения во время демонстрации.

Все поставленные цели выпускной квалификационной работы были достигнуты. Разработанная модель LightGBM показала высокую эффективность в задаче классификации клиентов на основе предложенного подхода к формированию признака лояльности. Спроектированная архитектура приложения и реализованные демонстрационные интерфейсы позволяют наглядно представить результаты работы модели и подтверждают возможность ее практического применения.

**Практическая значимость** работы заключается в создании инструмента, который может быть использован компанией Acoola для лучшего понимания своей клиентской базы, выявления потенциально уходящих клиентов и разработки целевых маркетинговых стратегий для повышения их лояльности. Предложенный подход к конструированию признаков и выбору модели может быть адаптирован и для других задач в сфере розничной торговли.

**Ограничениями** данного исследования являются использование данных за относительно короткий период (один месяц), что может не полностью отражать долгосрочные паттерны поведения клиентов, и специфический способ формирования целевой переменной, приведший к высоким метрикам. Кроме того, разработанное приложение является демонстрационным прототипом и не предназначено для промышленной эксплуатации без дальнейшей доработки.

**В качестве направлений для дальнейшего развития можно выделить:**
*   Использование данных за более длительный период для обучения и валидации моделей.
*   Эксперименты с альтернативными способами формирования целевого признака лояльности, возможно, с большим количеством градаций или на основе других бизнес-метрик.
*   Более глубокое исследование методов интерпретации моделей для получения детальных инсайтов о поведении различных сегментов клиентов.
*   Развитие демонстрационного приложения в полнофункциональную систему с интеграцией с CRM-системами компании, расширенными возможностями аналитики и автоматическим обновлением моделей.
*   Проведение A/B тестирования для оценки экономического эффекта от внедрения предложенных подходов к сегментации клиентов и удержанию.

Результаты данной работы представляют собой завершенное исследование, включающее как разработку и тщательную оценку моделей машинного обучения, так и продуманное проектирование системы для их практического использования. 